/*
 * generated by Xtext
 */
package ch.fhnw.mdt.serializer;

import ch.fhnw.mdt.services.UForthGrammarAccess;
import ch.fhnw.mdt.uForth.Create;
import ch.fhnw.mdt.uForth.Forth;
import ch.fhnw.mdt.uForth.Function;
import ch.fhnw.mdt.uForth.Instruction;
import ch.fhnw.mdt.uForth.Keywords;
import ch.fhnw.mdt.uForth.UForthPackage;
import ch.fhnw.mdt.uForth.Word;
import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class UForthSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private UForthGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == UForthPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case UForthPackage.CREATE:
				sequence_Create(context, (Create) semanticObject); 
				return; 
			case UForthPackage.FORTH:
				sequence_Forth(context, (Forth) semanticObject); 
				return; 
			case UForthPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case UForthPackage.INSTRUCTION:
				sequence_Instruction(context, (Instruction) semanticObject); 
				return; 
			case UForthPackage.KEYWORDS:
				sequence_Keywords(context, (Keywords) semanticObject); 
				return; 
			case UForthPackage.WORD:
				sequence_Word(context, (Word) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (name=ID lit+=Literal*)
	 */
	protected void sequence_Create(EObject context, Create semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     instructions+=GlobalInstruction*
	 */
	protected void sequence_Forth(EObject context, Forth semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID words+=Instruction*)
	 */
	protected void sequence_Function(EObject context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=Literal
	 */
	protected void sequence_Instruction(EObject context, Instruction semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UForthPackage.Literals.GLOBAL_INSTRUCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UForthPackage.Literals.GLOBAL_INSTRUCTION__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInstructionAccess().getNameLiteralParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name='SWAP' | 
	 *         name='OVER' | 
	 *         name='NIP' | 
	 *         name='UNDER' | 
	 *         name='TUCK' | 
	 *         name='ROT' | 
	 *         name='-ROT' | 
	 *         name='NEGATE' | 
	 *         name='DUP' | 
	 *         name='CALL'
	 *     )
	 */
	protected void sequence_Keywords(EObject context, Keywords semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID | name=OPERATOR)
	 */
	protected void sequence_Word(EObject context, Word semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
